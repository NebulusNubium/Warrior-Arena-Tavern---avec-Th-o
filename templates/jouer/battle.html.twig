{% extends 'base.html.twig' %}

{% block title %}Résultat de la bataille{% endblock %}

{% block body %}
<div class="battle-page">
    <h1>Résultat de la bataille</h1>
    <div class="row">
    <div class="col-md-6">
        <h2>Votre équipe</h2>
        <div class="character-list">
            {% for character in my_team %}
                <div class="character-item" id="char-L{{ character.id }}">
                    <h3>{{ character.name }}
                        {% if character.role %}
                            {% set roleClass = 'role-badge--' ~ (character.role.name|lower)|replace({' ':'-'}) %}
                            {% set roleKey = (character.role.name|lower)|replace({' ':'-'}) %}
                            <img src="{{ asset('build/images/roles/' ~ roleKey ~ '.png') }}" alt="{{ character.role.name }}" class="role-icon-img {{ roleKey }}" onerror="this.style.display='none'; this.nextElementSibling && (this.nextElementSibling.style.display='inline-block');" />
                            <span class="role-badge {{ roleClass }}" style="display:none">{{ character.role.name }}</span>
                        {% else %}
                            <span class="role-badge">&nbsp;</span>
                        {% endif %}
                    </h3>
                    <div>PV: <span class="hp" id="hp-L{{ character.id }}">{{ character.HP }}</span></div>
                </div>
            {% endfor %}
        </div>
    </div>
    <div class="col-md-6">
        <h2>Adversaire : {{ opponent.username }}</h2>
        <div class="character-list">
            {% for character in opponent_team %}
                <div class="character-item" id="char-R{{ character.id }}">
                    <h3>{{ character.name }}
                        {% if character.role %}
                            {% set roleClass = 'role-badge--' ~ (character.role.name|lower)|replace({' ':'-'}) %}
                            {% set roleKey = (character.role.name|lower)|replace({' ':'-'}) %}
                            <img src="{{ asset('build/images/roles/' ~ roleKey ~ '.png') }}" alt="{{ character.role.name }}" class="role-icon-img {{ roleKey }}" onerror="this.style.display='none'; this.nextElementSibling && (this.nextElementSibling.style.display='inline-block');" />
                            <span class="role-badge {{ roleClass }}" style="display:none">{{ character.role.name }}</span>
                        {% else %}
                            <span class="role-badge">&nbsp;</span>
                        {% endif %}
                    </h3>
                    <div>PV: <span class="hp" id="hp-R{{ character.id }}">{{ character.HP }}</span></div>
                </div>
            {% endfor %}
        </div>
    </div>
</div>
<div class="mt-4 row">
    <div class="col-md-8 text-center controls">
        <button id="play-battle" class="btn btn-danger btn-lg">Lancer l'animation</button>
        <button id="pause-battle" class="btn btn-secondary btn-lg">Pause Battle</button>
    <button id="speed-toggle" class="btn btn-info btn-lg">Accelerate</button>
    <button id="reset-battle" class="btn btn-warning btn-lg">Reset Battle</button>
    </div>
    <div class="col-md-4 text-center">
        <div id="round-counter">Round: 0</div>
    </div>
    <div class="col-md-4">
        <h4>Journal du combat</h4>
        <div id="battle-log"></div>
        <div id="battle-winner"></div>
    </div>
</div>
    </div>
<script>
// Data passed from the controller
const setup = {{ setup|json_encode|raw }};
const frames = {{ frames|json_encode|raw }};
const unitMap = {{ unit_map|json_encode|raw }};
const unitOwners = {{ unit_owners|json_encode|raw }};
let playTimeouts = [];
let isPaused = false;
let currentFrameIdx = 0;
let currentActionIdx = 0;
let currentFrame = null;
let currentActions = [];
let currentEvents = [];
let processNextActionRef = null;

// Timing configuration (ms)
let actionDelay = 1000; // delay between actions
let cleanupDelay = 300; // cleanup before frame snapshot
const acceleratedDelay = 200;
const normalDelay = 1000;
let isAccelerated = false;

// Build a map of unit max HP for clamping heals
const unitMaxHp = {};
if (setup) {
    (setup.left || []).forEach(u => unitMaxHp[u.id] = u.maxHp);
    (setup.right || []).forEach(u => unitMaxHp[u.id] = u.maxHp);
}

function clearAllTimeouts() {
    playTimeouts.forEach(id => clearTimeout(id));
    playTimeouts = [];
}

function resetVisuals() {
    document.querySelectorAll('.character-item').forEach(el => {
        el.classList.remove('glow-left','glow-right','glow-action','acting','targeted','heal');
    });
}

function resetTemporaryVisuals() {
    // Like resetVisuals but keep dead class
    document.querySelectorAll('.character-item').forEach(el => {
        el.classList.remove('glow-left','glow-right','glow-action','acting','targeted','heal');
    });
}

function syncHpSnapshot(hpByUnit) {
    Object.entries(hpByUnit || {}).forEach(([uid, hp]) => {
        const el = document.getElementById('hp-' + uid);
        if (el) el.textContent = hp;
        const box = document.getElementById('char-' + uid);
        if (box) {
            if (hp <= 0) box.classList.add('dead');
            else box.classList.remove('dead');
        }
    });
}

function playFrame(idx) {
    if (!frames || idx >= frames.length) {
        // finished
        // Show winner from server result
        let winner = {{ result.winnerTeamId is defined ? result.winnerTeamId|json_encode|raw : 'null' }};
        let winnerText = '';
        if (winner === 'left') {
            winnerText = 'Victoire : Votre équipe !';
        } else if (winner === 'right') {
            winnerText = 'Victoire : ' + {{ opponent.username|json_encode|raw }};
        } else {
            winnerText = 'Match nul !';
        }
        document.getElementById('battle-winner').textContent = winnerText;
        const p = document.createElement('div');
        p.textContent = 'Fin du combat.';
        document.getElementById('battle-log').appendChild(p);
        return;
    }

    resetTemporaryVisuals();
    currentFrameIdx = idx;
    resetVisuals();
    const frame = frames[idx];
    currentFrame = frame;

    // Update round counter if present
    if (typeof frame.round !== 'undefined') {
        const rc = document.getElementById('round-counter');
        if (rc) rc.textContent = 'Round: ' + frame.round;
    }

    // Append a clear round-start entry to the log
    const logDiv = document.getElementById('battle-log');
    const roundHeader = document.createElement('div');
    roundHeader.textContent = '--- Round ' + (typeof frame.round !== 'undefined' ? frame.round : currentFrameIdx+1) + ' start (' + (frame.starter ? (frame.starter === 'left' ? 'Your team' : 'Opponent') : 'N/A') + ') ---';
    roundHeader.classList.add('log-round');
    logDiv.appendChild(roundHeader);
    logDiv.scrollTop = logDiv.scrollHeight;

    // If frame contains roundEvents (global AoE from round), render them first
    if (frame.roundEvents && frame.roundEvents.length) {
        const logDiv = document.getElementById('battle-log');
        frame.roundEvents.forEach(ev => { const p = document.createElement('div'); p.textContent = ev; logDiv.appendChild(p); });
        logDiv.scrollTop = logDiv.scrollHeight;
    }

    // clear any previous team-wide glow (we'll set it per-action)
    Object.keys(unitMap).forEach(uid => {
        const el = document.getElementById('char-' + uid);
        if (el) { el.classList.remove('glow-left','glow-right'); }
    });

    // local hp map to incrementally update UI
    const localHp = {};
    Object.keys(unitMap).forEach(uid => {
        const el = document.getElementById('hp-' + uid);
        localHp[uid] = el ? parseInt(el.textContent || '0', 10) : (frame.hpByUnit && frame.hpByUnit[uid] ? frame.hpByUnit[uid] : 0);
    });

    currentActions = frame.actions || [];
    currentEvents = frame.events || [];
    currentActionIdx = 0;

    function processNextAction() {
        if (isPaused) return; // paused, do nothing

        // If there are no actions, just sync snapshot and advance after 1s
        if (!currentActions || currentActions.length === 0) {
            if (currentEvents.length) {
                const logDiv = document.getElementById('battle-log');
                currentEvents.forEach(ev => { const p = document.createElement('div'); p.textContent = ev; logDiv.appendChild(p); });
                logDiv.scrollTop = logDiv.scrollHeight;
            }
            syncHpSnapshot(frame.hpByUnit);
            const t = setTimeout(() => playFrame(currentFrameIdx + 1), actionDelay);
            playTimeouts.push(t);
            return;
        }

        if (currentActionIdx >= currentActions.length) {
            // end of actions for this frame: sync snapshot then go to next frame after 1s
            setTimeout(() => {
                syncHpSnapshot(frame.hpByUnit);
                if (!isPaused) {
                    const t = setTimeout(() => playFrame(currentFrameIdx + 1), actionDelay);
                    playTimeouts.push(t);
                }
            }, cleanupDelay);
            return;
        }

        const action = currentActions[currentActionIdx];

        // perform this action immediately
        const actorEl = document.getElementById('char-' + action.actorId);
        const targetEl = action.targetId ? document.getElementById('char-' + action.targetId) : null;
        if (actorEl) {
            actorEl.classList.add('acting');
            // highlight actor's team while acting
            const teamPrefix = action.actorId.startsWith('L') ? 'L' : 'R';
            Object.keys(unitMap).forEach(uid => {
                if (uid.startsWith(teamPrefix)) {
                    const el = document.getElementById('char-' + uid);
                    if (el) el.classList.add(teamPrefix === 'L' ? 'glow-left' : 'glow-right');
                }
            });
        }
        if (targetEl) targetEl.classList.add('targeted');
        if (action.kind === 'HEAL') {
            if (actorEl) actorEl.classList.add('heal');
            if (targetEl) targetEl.classList.add('heal');
        }

        // update HP display incrementally
        if (action.kind === 'ATTACK') {
            const tid = action.targetId;
            if (typeof localHp[tid] !== 'undefined') {
                localHp[tid] = Math.max(0, localHp[tid] - action.amount);
                const hpEl = document.getElementById('hp-' + tid);
                if (hpEl) hpEl.textContent = localHp[tid];
                const box = document.getElementById('char-' + tid);
                if (box && localHp[tid] <= 0) box.classList.add('dead');
            }
        } else if (action.kind === 'HEAL') {
            const tid = action.targetId;
            if (typeof localHp[tid] !== 'undefined') {
                const maxHp = unitMaxHp[tid] || 9999;
                localHp[tid] = Math.min(maxHp, localHp[tid] + action.amount);
                const hpEl = document.getElementById('hp-' + tid);
                if (hpEl) hpEl.textContent = localHp[tid];
                const box = document.getElementById('char-' + tid);
                if (box && localHp[tid] > 0) box.classList.remove('dead');
            }
        }

        // append corresponding event if available
        const logDiv = document.getElementById('battle-log');
        if (currentEvents[currentActionIdx]) {
            const p = document.createElement('div');
            p.textContent = currentEvents[currentActionIdx];
            // highlight critical hits
            if (action && action.critical) {
                p.classList.add('log-crit');
                // add a visible crit flash to actor/target
                if (actorEl) actorEl.classList.add('crit-flash');
                if (targetEl) targetEl.classList.add('crit-flash');
            }
            logDiv.appendChild(p);
            logDiv.scrollTop = logDiv.scrollHeight;
        }

        // schedule cleanup for this action
    const cleanup = setTimeout(() => {
            if (actorEl) actorEl.classList.remove('acting');
            if (targetEl) targetEl.classList.remove('targeted');
            if (actorEl) actorEl.classList.remove('heal');
            if (targetEl) targetEl.classList.remove('heal');
            // ensure critical flash is removed after action
            if (actorEl) actorEl.classList.remove('crit-flash');
            if (targetEl) targetEl.classList.remove('crit-flash');
            // remove the team-wide highlight after action finishes
            const teamPrefix = action.actorId.startsWith('L') ? 'L' : 'R';
            Object.keys(unitMap).forEach(uid => {
                if (uid.startsWith(teamPrefix)) {
                    const el = document.getElementById('char-' + uid);
                    if (el) el.classList.remove(teamPrefix === 'L' ? 'glow-left' : 'glow-right');
                }
            });
    }, Math.max(120, Math.round(cleanupDelay * 1.5)));
        playTimeouts.push(cleanup);

    // schedule next action after actionDelay (if not paused)
    const nextTimer = setTimeout(() => {
            currentActionIdx++;
            processNextAction();
    }, actionDelay);
        playTimeouts.push(nextTimer);
    }

    // Start processing actions for this frame
    processNextActionRef = processNextAction;
    processNextAction();
}

document.getElementById('play-battle').addEventListener('click', function() {
    // Stop any previous run
    clearAllTimeouts();
    resetVisuals();
    document.getElementById('battle-log').innerHTML = '';
    document.getElementById('battle-winner').textContent = '';
    isPaused = false;
    processNextActionRef = null;

    if (!frames || frames.length === 0) {
        const logDiv = document.getElementById('battle-log');
        const p = document.createElement('div');
        p.textContent = 'No frames available.';
        logDiv.appendChild(p);
        return;
    }

    playFrame(0);
});

document.getElementById('pause-battle').addEventListener('click', function() {
    isPaused = !isPaused;
    this.textContent = isPaused ? 'Resume Battle' : 'Pause Battle';
    if (!isPaused) {
        // resume: continue processing current frame/action
        if (currentFrameIdx < frames.length) {
            // clear any lingering timeouts and continue
            clearAllTimeouts();
            // resume action processing at currentActionIdx
            // small delay to allow visuals to settle
            setTimeout(() => {
                // continue from the stored processNextActionRef which preserves indices
                if (processNextActionRef) processNextActionRef();
            }, 120);
        }
    } else {
        // paused: stop scheduling future timers
        clearAllTimeouts();
    }
});

document.getElementById('speed-toggle').addEventListener('click', function() {
    isAccelerated = !isAccelerated;
    actionDelay = isAccelerated ? acceleratedDelay : normalDelay;
    this.textContent = isAccelerated ? 'Normal Speed' : 'Accelerate';
    // If currently playing, clear pending timeouts so new delays apply immediately
    if (!isPaused && processNextActionRef) {
        clearAllTimeouts();
        // small delay to settle visuals, then resume
        setTimeout(() => { if (processNextActionRef) processNextActionRef(); }, 80);
    }
});

// Reset button: restore all units to full HP and clear dead visuals/logs
document.getElementById('reset-battle').addEventListener('click', function() {
    // Stop any running timers and animations
    clearAllTimeouts();
    // Reset internal indices and processing refs
    isPaused = true;
    currentFrameIdx = 0;
    currentActionIdx = 0;
    currentFrame = null;
    currentActions = [];
    currentEvents = [];
    processNextActionRef = null;

    // Restore HP from setup (uses unitMaxHp computed earlier)
    Object.keys(unitMaxHp).forEach(uid => {
        const hpEl = document.getElementById('hp-' + uid);
        if (hpEl) hpEl.textContent = unitMaxHp[uid];
        const box = document.getElementById('char-' + uid);
        if (box) box.classList.remove('dead');
    });

    // Clear visuals and log/winner/round
    resetVisuals();
    const logDiv = document.getElementById('battle-log');
    if (logDiv) logDiv.innerHTML = '';
    const winnerDiv = document.getElementById('battle-winner');
    if (winnerDiv) winnerDiv.textContent = '';
    const rc = document.getElementById('round-counter');
    if (rc) rc.textContent = 'Round: 0';

    // Un-accelerate to default speed for clarity
    isAccelerated = false;
    actionDelay = normalDelay;
    const speedBtn = document.getElementById('speed-toggle');
    if (speedBtn) speedBtn.textContent = 'Accelerate';
});
</script>

<div class="debug-setup">Debug setup JSON (use this to implement your engine):
    <pre class="debug-pre">{{ setup|json_encode(constant('JSON_PRETTY_PRINT'))|raw }}</pre>
</div>
{% endblock %}
